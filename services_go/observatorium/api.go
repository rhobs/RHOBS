package observatorium

import (
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/bwplotka/mimic"
	"github.com/bwplotka/mimic/encoding"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/memcached"
	observatoriumapi "github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/observatorium/api"
	observatoriumup "github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/observatorium/up"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/prometheus/avalanche"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/thanos/ruler"
	"github.com/observatorium/observatorium/configuration_go/kubegen/containeropts"
	kghelpers "github.com/observatorium/observatorium/configuration_go/kubegen/helpers"
	"github.com/observatorium/observatorium/configuration_go/kubegen/openshift"
	"github.com/observatorium/observatorium/configuration_go/kubegen/workload"
	"github.com/observatorium/observatorium/configuration_go/schemas/log"
	upoptions "github.com/observatorium/up/pkg/options"
	templatev1 "github.com/openshift/api/template/v1"
	monv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

const (
	obsApiImage          = "quay.io/observatorium/api"
	obsApiTag            = "main-2023-12-06-62d7703"
	gubernatorImage      = "quay.io/app-sre/gubernator"
	gubernatorTag        = "v2.0.0-rc.36"
	observatoriumUpImage = "quay.io/observatorium/up"
	observatoriumUpTag   = "master-2022-03-24-098c31a"
	avalancheImage       = "quay.io/prometheuscommunity/avalanche"
	avalancheTag         = "main"
	obsctlReloaderImage  = "quay.io/app-sre/obsctl-reloader"
	obsctlReloaderTag    = "969b895"
	rulesObjstoreName    = "observatorium-rules-objstore"
	rulesObjstoreTag     = "main-2022-09-21-9df4d2c"
)

type ObservatoriumAPI struct {
	Namespace                    string
	Tenants                      []observatoriumapi.Tenant
	ThanosImageTag               string
	APIPremanifestsHook          func(*observatoriumapi.ObservatoriumAPIDeployment)
	CachePremanifestsHook        func(*memcached.MemcachedDeployment)
	GubernatorPremanifestsHook   func(*observatoriumapi.GubernatorDeployment)
	RBAC                         string
	AmsUrl                       string
	UpQueryFrontendOpts          func(*observatoriumup.UpOptions)
	UpQueryFrontendDeploy        func(*observatoriumup.UpDeployment)
	UpQueriesTenant              string
	AvalancheOpts                func(*avalanche.AvalancheOptions)
	AvalancheDeploy              func(*avalanche.AvalancheDeployment)
	ObsCtlReloaderManagedTenants []string
	RuleObjStoreSecret           string
	TemplateParams               []templatev1.Parameter
}

func (o *ObservatoriumAPI) Manifests(generator *mimic.Generator) {
	withStatusRemove := func(encoder encoding.Encoder) encoding.Encoder {
		return &statusRemoveEncoder{encoder: encoder}
	}

	generator.Add("observatorium-api-template.yaml", withStatusRemove(o.makeAPI()))
}

func (o *ObservatoriumAPI) makeAPI() encoding.Encoder {
	templateParams := []templatev1.Parameter{} // collects template params generated by subcomponents
	templateParams = append(templateParams, o.TemplateParams...)

	// Observatorium api config
	gubernatorName := "observatorium-gubernator"
	tenantsConfig := &observatoriumapi.Tenants{Tenants: o.Tenants}
	opts := &observatoriumapi.ObservatoriumAPIOptions{
		InternalTracingEndpoint:          "localhost:6831",
		LogLevel:                         log.LevelWarn,
		MiddlewareRateLimiterGrpcAddress: fmt.Sprintf("%s.%s.svc.cluster.local:8081", gubernatorName, o.Namespace),
		MetricsReadEndpoint:              fmt.Sprintf("http://%s.%s.svc.cluster.local:9090", obsQueryFrontendName, o.Namespace),
		MetricsWriteEndpoint:             fmt.Sprintf("http://%s.%s.svc.cluster.local:19291", receiveRouterName, o.Namespace),
		MetricsRulesEndpoint:             fmt.Sprintf("http://%s.%s.svc.cluster.local:8080", rulesObjstoreName, o.Namespace),
		MetricsAlertmanagerEndpoint:      fmt.Sprintf("http://%s.%s.svc.cluster.local:9093", alertManagerName, o.Namespace),
		TenantsConfig:                    observatoriumapi.NewTenantsConfig(tenantsConfig).AsSecret(),
	}

	if o.RBAC != "" {
		opts.RbacConfig = observatoriumapi.NewRbacConfig(nil).WithValue(o.RBAC)
	}

	// K8s config
	obsapi := observatoriumapi.NewObservatoriumAPI(opts, o.Namespace, obsApiTag)
	obsapi.Image = obsApiImage
	obsapi.Replicas = 1
	delete(obsapi.ContainerResources.Limits, corev1.ResourceCPU)
	opaAmsCache := "observatorium-api-cache-memcached"
	cacheURL := fmt.Sprintf("%s.%s.svc.cluster.local:11211", opaAmsCache, o.Namespace)

	amsOidcClientSecretName := "observatorium-ams-oidc-client-secret"
	amsSideCar := o.makeOpaAms(o.AmsUrl, cacheURL, amsOidcClientSecretName)
	amsSideCar.Secrets = map[string]map[string][]byte{
		amsOidcClientSecretName: {
			"client-id":     []byte("${AMS_OIDC_CLIENT_ID}"),
			"client-secret": []byte("${AMS_OIDC_CLIENT_SECRET}"),
			"issuer-url":    []byte("${AMS_OIDC_ISSUER_URL}"),
		},
	}
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_CLIENT_ID"})
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_CLIENT_SECRET"})
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_ISSUER_URL"})

	obsapi.Sidecars = []workload.ContainerProvider{
		makeJaegerAgent("observatorium-tools"),
		amsSideCar,
	}

	// Execute preManifestsHook
	executeIfNotNil(o.APIPremanifestsHook, obsapi)

	// Post process
	manifests := obsapi.Objects()
	postProcessServiceMonitor(kghelpers.GetObject[*monv1.ServiceMonitor](manifests, ""), obsapi.Namespace)
	addQuayPullSecret(kghelpers.GetObject[*corev1.ServiceAccount](manifests, ""))

	// Add rules objstore
	manifests = append(manifests, o.makeRulesObjstore()...)

	// Add cache
	cachePreManHook := func(memdep *memcached.MemcachedDeployment) {
		memdep.CommonLabels[workload.ComponentLabel] = "api-cache"
		executeIfNotNil(o.CachePremanifestsHook, memdep)
	}
	manifests = append(manifests, makeMemcached(opaAmsCache, o.Namespace, cachePreManHook)...)

	// Add gubernator
	manifests = append(manifests, o.makeGubernator(gubernatorName)...)

	// Add obsctl reloader
	manifests = append(manifests, o.makeObsCtlReloader(obsapi.Name)...)

	// Add up query frontend
	endpoint := fmt.Sprintf("http://observatorium-thanos-query-frontend.%s.svc.cluster.local:9090", o.Namespace)
	manifests = append(manifests, o.makeUp("observatorium-up-query-frontend", endpoint)...)

	// Add up ruler
	endpoint = fmt.Sprintf("http://observatorium-thanos-query-rule.%s.svc.cluster.local:9090", o.Namespace)
	manifests = append(manifests, o.makeUp("observatorium-up-query-rule", endpoint)...)

	// Add avalanche
	manifests = append(manifests, o.makeAvalanche()...)

	// Set encoders and template params
	cacheEncoder := NewStdTemplateYAML(opaAmsCache, "CACHE")
	templateParams = append(templateParams, cacheEncoder.TemplateParams()...)
	apiEncoder := NewStdTemplateYAML(obsapi.Name, "OBSAPI").WithLogLevel()
	templateParams = append(templateParams, apiEncoder.TemplateParams()...)
	template := openshift.WrapInTemplate(manifests, metav1.ObjectMeta{
		Name: obsapi.Name,
	}, sortTemplateParams(templateParams))

	return cacheEncoder.Wrap(apiEncoder.Wrap(encoding.GhodssYAML(template)))
}

func (o *ObservatoriumAPI) makeRulesObjstore() []runtime.Object {
	opts := ruler.NewRulesObjstoreDefaultOptions()
	opts.LogLevel = string(log.LevelWarn)
	opts.LogFormat = string(log.FormatLogfmt)
	opts.ObjstoreConfigFile = containeropts.NewFileInVolume("objstore-config", "/etc/rules-objstore/objstore", "config.yaml")

	rulesObjstore := ruler.NewRulesObjstore(opts, o.Namespace, rulesObjstoreTag)
	rulesObjstore.Name = rulesObjstoreName

	// Rules objstore expects a file with the objstore config.
	// We generate the file from the env vars using an init container
	// that writes the file to a shared volume.
	initContainer := &workload.Container{
		Name:            "init",
		Image:           "quay.io/app-sre/ubi8-ubi-minimal",
		ImageTag:        "8.9",
		ImagePullPolicy: corev1.PullIfNotPresent,
		Command:         []string{"/bin/sh", "-c", "echo \"${OBJSTORE_CONFIG}\" > /tmp/config/config.yaml"},
		Env:             objStoreEnvVars(o.RuleObjStoreSecret),
		VolumeMounts: []corev1.VolumeMount{
			{
				Name:      "objstore-config",
				MountPath: "/tmp/config",
			},
		},
		Volumes: []corev1.Volume{
			{
				Name: "objstore-config",
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{},
				},
			},
		},
	}
	rulesObjstore.InitContainers = append(rulesObjstore.InitContainers, initContainer)

	manifests := rulesObjstore.Objects()

	return manifests
}

func (o *ObservatoriumAPI) makeOpaAms(amsURL, memcachedUrl, clientSecretName string) *workload.Container {
	opts := &observatoriumapi.OpaAmsOptions{
		WebListen:               &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 8082},
		WebInternalListen:       &net.TCPAddr{IP: net.IPv4(0, 0, 0, 0), Port: 8083},
		WebHealthchecksURL:      "http://localhost:8082",
		LogLevel:                "warn",
		AmsURL:                  amsURL,
		ResourceTypePrefix:      "observatorium",
		OidcClientID:            "$(CLIENT_ID)",
		OidcClientSecret:        "$(CLIENT_SECRET)",
		OidcIssuerURL:           "$(ISSUER_URL)",
		OpaPackage:              "observatorium",
		Memcached:               memcachedUrl,
		MemcachedExpire:         300,
		InternalTracingEndpoint: &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 6831},
	}

	ret := observatoriumapi.MakeOpaAms(opts, true)
	ret.ImageTag = "master-2022-11-03-222daab"
	ret.Env = append(ret.Env, kghelpers.NewEnvFromSecret("CLIENT_ID", clientSecretName, "client-id"))
	ret.Env = append(ret.Env, kghelpers.NewEnvFromSecret("CLIENT_SECRET", clientSecretName, "client-secret"))
	ret.Env = append(ret.Env, kghelpers.NewEnvFromSecret("ISSUER_URL", clientSecretName, "issuer-url"))

	return ret
}

func (o *ObservatoriumAPI) makeGubernator(name string) []runtime.Object {
	gube := observatoriumapi.NewGubernatorDeployment(o.Namespace, gubernatorTag)
	gube.Image = gubernatorImage
	gube.Replicas = 1
	gube.Name = name
	executeIfNotNil(o.GubernatorPremanifestsHook, gube)

	// Post process
	manifests := gube.Objects()
	postProcessServiceMonitor(kghelpers.GetObject[*monv1.ServiceMonitor](manifests, ""), gube.Namespace)
	addQuayPullSecret(kghelpers.GetObject[*corev1.ServiceAccount](manifests, ""))

	return manifests
}

func (o *ObservatoriumAPI) makeUp(name, endpoint string) []runtime.Object {
	opts := &observatoriumup.UpOptions{}
	opts.LogLevel = log.LevelInfo
	opts.EndpointType = observatoriumup.EndpointTypeMetrics
	opts.EndpointRead = fmt.Sprintf("http://observatorium-thanos-query-frontend.%s.svc.cluster.local:9090", o.Namespace)
	zeroDur := time.Duration(0)
	opts.Duration = &zeroDur
	opts.QueriesFile = observatoriumup.NewQueriesFileOption(&observatoriumup.QueriesFile{
		Queries: []upoptions.QuerySpec{
			{
				Name:  "query-path-sli-1M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[1h])", o.UpQueriesTenant),
			},
			{
				Name:  "query-path-sli-10M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[10h])", o.UpQueriesTenant),
			},
			{
				Name:  "query-path-sli-100M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[100h])", o.UpQueriesTenant),
			},
		},
	}).WithResourceName(name + "-queries")
	executeIfNotNil(o.UpQueryFrontendOpts, opts)

	obsup := observatoriumup.NewUp(opts, o.Namespace, observatoriumUpTag)
	obsup.Image = observatoriumUpImage
	obsup.Name = name
	executeIfNotNil(o.UpQueryFrontendDeploy, obsup)

	// Post process
	manifests := obsup.Objects()
	postProcessServiceMonitor(kghelpers.GetObject[*monv1.ServiceMonitor](manifests, ""), obsup.Namespace)
	addQuayPullSecret(kghelpers.GetObject[*corev1.ServiceAccount](manifests, obsup.Name))

	return manifests
}

func (o *ObservatoriumAPI) makeAvalanche() []runtime.Object {
	opts := &avalanche.AvalancheOptions{}
	opts.MetricCount = 1
	opts.SeriesCount = 8333
	opts.RemoteURL = fmt.Sprintf("http://observatorium-thanos-receive-router.%s.svc.cluster.local:19291/api/v1/receive", o.Namespace)
	opts.RemoteWriteInterval = time.Duration(30) * time.Second
	opts.RemoteRequestsCount = 10e6
	opts.ValueInterval = 3600
	opts.SeriesInterval = 315360000 // 10y
	opts.MetricInterval = 315360000 // 10y
	opts.RemoteTenantHeader = "THANOS-TENANT"
	opts.RemoteTenant = o.UpQueriesTenant
	executeIfNotNil(o.AvalancheOpts, opts)

	aval := avalanche.NewAvalanche(opts, o.Namespace, avalancheTag)
	aval.Image = avalancheImage
	executeIfNotNil(o.AvalancheDeploy, aval)

	// Post process
	manifests := aval.Objects()
	postProcessServiceMonitor(kghelpers.GetObject[*monv1.ServiceMonitor](manifests, ""), aval.Namespace)
	addQuayPullSecret(kghelpers.GetObject[*corev1.ServiceAccount](manifests, aval.Name))

	return manifests
}

func (o *ObservatoriumAPI) makeObsCtlReloader(obsApiName string) []runtime.Object {
	depl := workload.DeploymentWorkload{
		Replicas: 1,
		PodConfig: workload.PodConfig{
			Name:            "observatorium-obsctl-reloader",
			Namespace:       o.Namespace,
			Image:           obsctlReloaderImage,
			ImageTag:        obsctlReloaderTag,
			ImagePullPolicy: corev1.PullIfNotPresent,
			Env: []corev1.EnvVar{
				{
					Name: "NAMESPACE_NAME",
					ValueFrom: &corev1.EnvVarSource{
						FieldRef: &corev1.ObjectFieldSelector{
							FieldPath: "metadata.namespace",
						},
					},
				},
			},
			EnableServiceMonitor: true,
			CommonLabels: map[string]string{
				workload.NameLabel:      "rules-obsctl-reloader",
				workload.InstanceLabel:  "observatorium",
				workload.PartOfLabel:    "observatorium",
				workload.ComponentLabel: "rules-obsctl-reloader",
				workload.VersionLabel:   obsctlReloaderTag,
			},
			ContainerResources:            kghelpers.NewResourcesRequirements("50m", "", "500Mi", "2Gi"),
			TerminationGracePeriodSeconds: 30,
		},
	}

	container := depl.ToContainer()
	container.Name = "obsctl-reloader"
	internalPort := 8081
	container.Args = []string{
		"--log.level=debug",
		fmt.Sprintf("--web.internal.listen=0.0.0.0:%d", internalPort),
		"--sleep-duration-seconds=16",
		"--config-reload-interval-seconds=60",
		fmt.Sprintf("--observatorium-api-url=http://%s.%s.svc.cluster.local:8080", obsApiName, o.Namespace),
		"--managed-tenants=" + strings.Join(o.ObsCtlReloaderManagedTenants, ","),
		"--issuer-url=https://sso.redhat.com/auth/realms/redhat-external",
		"--audience=observatorium",
		"--log-rules-enabled=false",
	}
	container.Ports = []corev1.ContainerPort{
		{
			Name:          "http",
			ContainerPort: int32(internalPort),
			Protocol:      corev1.ProtocolTCP,
		},
	}
	container.ServicePorts = []corev1.ServicePort{kghelpers.NewServicePort("http", internalPort, internalPort)}
	container.MonitorPorts = []monv1.Endpoint{{Port: "http"}}

	manifests := depl.Objects(container)

	postProcessServiceMonitor(kghelpers.GetObject[*monv1.ServiceMonitor](manifests, ""), depl.Namespace)
	addQuayPullSecret(kghelpers.GetObject[*corev1.ServiceAccount](manifests, depl.Name))

	rbacRole := &rbacv1.Role{
		TypeMeta:   workload.RoleMeta,
		ObjectMeta: depl.ObjectMeta().MakeMeta(),
		Rules: []rbacv1.PolicyRule{
			{
				APIGroups: []string{"monitoring.coreos.com"},
				Resources: []string{"prometheusrules"},
				Verbs:     []string{"list", "watch", "get"},
			},
			{
				APIGroups: []string{"loki.grafana.com"},
				Resources: []string{"alertingrules", "recordingrules"},
				Verbs:     []string{"list", "watch", "get"},
			},
			{
				APIGroups: []string{""},
				Resources: []string{"secrets"},
				Verbs:     []string{"list", "watch", "get"},
			},
		},
	}
	manifests = append(manifests, rbacRole)

	sa := kghelpers.GetObject[*corev1.ServiceAccount](manifests, depl.Name)
	roleBinding := &rbacv1.RoleBinding{
		TypeMeta:   workload.RoleBindingMeta,
		ObjectMeta: depl.ObjectMeta().MakeMeta(),
		Subjects: []rbacv1.Subject{
			{
				Kind:      sa.GetObjectKind().GroupVersionKind().Kind,
				Name:      sa.GetName(),
				Namespace: sa.GetNamespace(),
			},
		},
		RoleRef: rbacv1.RoleRef{
			Kind:     rbacRole.GetObjectKind().GroupVersionKind().Kind,
			APIGroup: rbacRole.GetObjectKind().GroupVersionKind().Group,
			Name:     rbacRole.GetName(),
		},
	}
	manifests = append(manifests, roleBinding)

	return manifests
}
